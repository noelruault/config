#!/bin/bash

alias hs='history | grep'
alias hibernate="sudo systemctl hibernate"

# dot_clean -> Remove dot-underscore files. Merges ._* files with corresponding native files. # https://ss64.com/osx/dot_clean.html
alias ds_clean="find . -name '.DS_Store' -type f -delete"

# IP ADDRESSES
alias wanip='dig +short myip.opendns.com @resolver1.opendns.com'
alias localhosts='ifconfig | grep "inet " | grep -v 127.0.0.1'  # https://stackoverflow.com/a/4779992

# CP command, do rsync if file is a folder or higher than 50MB  // rsync -ah --progress
alias cp='rsync -ah --progress'

### Sublime
# alias sublsettingsf="subl '$(find $HOME -type d -name "*Sublime*Text*" 2>&1 | grep -v "find")/Packages/User/'*sublime*"
# alias sublsettings='subl '$(find $HOME -type d -name "*Sublime*Text*" 2>&1 | grep -v "find")/Packages/User/''

### Emacs
# alias emacs="/usr/local/bin/emacs"

### GIT
alias gamod="git ls-files --modified | xargs git add"
# Remove all your local git branches but keep master and the current branch:
alias greset='git branch | egrep -v "(master|\*)" | xargs git branch -D'
alias githooksconfig='git config --global core.hooksPath ~/.config/git/hooks/'
### Vagrant
alias vagrantclean="vagrant box list | cut -f 1 -d ' ' | xargs -L 1 vagrant box remove -f"

function search() { find / -name "$@" | echo; }

function pro_rebase(){
    # https://stackoverflow.com/a/927386
    regex='^[0-9]+$'
    if [[ $@ =~ $regex ]] ; then
        git rebase -i HEAD~"$@"
        echo "Remember to push with --force flag."
    else
        echo "How pro_rebase works:"
        echo "  Put as first param the number of commits you want to cover (1-N)."
        echo "  e.g: pro_rebase 3  == git rebase -i HEAD~3"
        echo "  Squash commits or whatever and then push your chages with --force"
    fi
}

alias awesome='cat $ZSH_CUSTOM_CONFIG_FILES/awesome.txt'

### GOLANG
# alias gotest='go test ./... -p 1 -v'
# TODO:
# https://stackoverflow.com/a/30033822/4349318
gotest(){

    # if [[ "$1" == "color" ]]; then
    go test ./... -p 1 -count 1 -v \
    | sed ''/PASS/s//$(printf "\033[32mPASS\033[0m")/'' \
    | sed ''/FAIL/s//$(printf "\033[31mFAIL\033[0m")/'' # \
    ## | GREP_COLOR="01;33" egrep --color=always '\s*[a-zA-Z0-9\-_.]+[:][0-9]+[:]|^'
    # return

    if [[ "$1" == "e2e" ]]; then
        go test ./test/endtoend -tags=endtoend -count=1 -timeout 120s \
        | sed ''/PASS/s//$(printf "\033[32mPASS\033[0m")/'' \
        | sed ''/FAIL/s//$(printf "\033[31mFAIL\033[0m")/''
    fi
}

gocover () {
  local t=$(mktemp -t cover)
  go test $COVERFLAGS -coverprofile=$t $@ && go tool cover -func=$t && unlink $t
}
# for pkg in *; do go test "./$pkg"; done
# go clean -testcache # https://golang.org/pkg/cmd/go/internal/clean/

# CD ANYWHERE aliases
alias gow='cd ~/Work'
alias gopath='cd $(go env GOPATH)'
alias gosrc='cd $(go env GOPATH)/src/'
alias goa=go_to_dir_on_specific_folder # A $COMPANY_DIRECTORY needs to be configured

# go_to_dir_on_specific_folder will try to find a directory that matches
# with the given parameters inside of an specific folder.
#
# Note: WORK_FOLDER variable could be changed to something else, more specific
# and without evaluations or commands. It's done this way for confidentiality.
#
# Used uncommon commands :
# - https://ss64.com/bash/wc.html
# - https://ss64.com/bash/awk.html
# - Colors: https://www.tldp.org/HOWTO/Bash-Prompt-HOWTO/x329.html https://www.shellhacks.com/bash-colors/
function go_to_dir_on_specific_folder() {
    WORK_FOLDER=$(eval echo $(go env GOPATH)/src/$COMPANY_DIRECTORY/) # eval will store the desired payments path.

    # If there is no arguments, just go to $COMPANY_DIRECTORY
    if [[ $# -eq 0 ]] ; then
        cd $WORK_FOLDER
        return
    fi

    counter=$(find $WORK_FOLDER -type d -name "*$1*$2*" -print -maxdepth 1 | wc -l) # wc is used for counting the lines
    if (( $counter == 0 )); then
        # An inverted counter will try to find matches inverting the order of the params.
        inverted_counter=$(find $WORK_FOLDER -type d -name "*$2*$1*" -print -maxdepth 1 | wc -l)
        if (( $inverted_counter > 0 )); then
            # If something matches, will display the results in addition to a tip.
            echo "Better try \e[0;33m$2 $1\e[0m"
            echo "Found:\n\e[0;34m$(find $WORK_FOLDER -type d -name "*$2*$1*" -print -maxdepth 1 | awk -F/ '{print $NF}')\e[0m"
            return
        fi

        echo "No matches."
        return

    elif (( $counter > 1 )); then
        # If more than one folder were found, print the results
        find $WORK_FOLDER -type d -name "*$1*$2*" -print -maxdepth 1 | awk -F/ '{print $NF}' # awk is used for getting the name of the folder without the path
        return
    else
        # If only one folder was found, change to the found directory
        cd $WORK_FOLDER$(find $WORK_FOLDER -type d -name "*$1*$2*" -print -maxdepth 1 | awk -F/ '{print $NF}')
    fi;
}

alias crypto\?='go run $ZSH_CUSTOM_CONFIG_FILES/crypto.go &'
